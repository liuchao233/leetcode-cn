问题描述：
给你两个单链表的头节点 headA 和 headB, 请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

解题思路1：
分别计算两个单链表的长度 lenA 和 lenB, 计算两个链表的长度差 offset，之后同时回到起点，让较长的先移动 offset 个位置，之后再挨个进行比较。

时间复杂度：O(n)
空间复杂度: O(1)

缺点：要记录单链表的长度，如果长度非常大，不容易存储

解题思路2：
1. 只有 headA 和 headB 都不为空的时候，两个链表才能相交。
2. 创建指针 pa 和 pb，然后依次遍历两个链表
    * 同时向后移动 pa 和 pb
    * 若 pa 不为空，则向后移动一个位置；若 pb 不为空，则向后移动一个位置。
    * 若 pa 为空，则将 pa 移动到 headB；若 pb 为空，则移动到 headA。
    * 若 pa 和 pb 指向同一个节点或者都为空时，返回指向的节点或空

原理：
假设 headA 不相交长度为 a, headB 不相交长度为 b，相交的长度为 c。

则 headA 的长度为 a + c, headB 的长度为 b + c。

若 headA 和 headB 相交，则分别移动 a + c + b 和 b + c + a 后会相交。

若 headA 和 headB 不相交，则 c = 0，则移动 a + b 和 b + a 后会同时指向 nullptr。

